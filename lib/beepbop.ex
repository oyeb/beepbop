defmodule BeepBop do
  @moduledoc """
  Manages the state machine of an `Ecto.Schema`.
  """

  @doc """
  Configures `BeepBop` to work with your `Ecto.Repo`.

  Expected keyword arguments:
  * `:ecto_repo` -- Since BeepBop does the routine persisting of "state", it
    needs to know which `Ecto.Repo` to use.
  """
  defmacro __using__(opts) do
    unless Keyword.has_key?(opts, :ecto_repo) do
      raise(~s{Please configure an Ecto.Repo by passing an Ecto.Repo
    like so:
    use BeepBop, ecto_repo: YourProject.Repo
})
    end

    quote do
      import BeepBop
      alias Ecto.Multi

      @repo_opts nil
      @beepbop_repo Keyword.fetch!(unquote(opts), :ecto_repo)
    end
  end

  defmacro state_machine(schema, column, do: block) do
    {:__aliases__, _, module_list} = schema

    quote location: :keep do
      if @repo_opts == nil, do: @repo_opts([])

      @beepbop_state_column unquote(column)
      @beepbop_schema_module unquote(schema)
      @beepbop_schema_name unquote(module_list)
                           |> List.last()
                           |> Atom.to_string()
                           |> Macro.underscore()
                           |> String.to_atom()

      defp _beepbop_extract_struct(context) do
        case Map.fetch(context, @beepbop_schema_name) do
          {:ok, %unquote(schema){} = struct} ->
            struct

          {:ok, _} ->
            nil

          :error ->
            nil
        end
      end

      defp _beepbop_try_persist(multi, struct, to_state) do
        Multi.run(multi, :persist, fn changes ->
          updated_struct = _beepbop_extract_struct(changes) || struct
          to = Atom.to_string(to_state)

          try do
            __MODULE__.persist(updated_struct, to)
          rescue
            UndefinedFunctionError ->
              {:ok, Map.put(updated_struct, @beepbop_state_column, to)}
          end
        end)
      end

      unquote(block)
    end
  end

  defmacro states(states) do
    quote do
      @beepbop_states unquote(states)

      @doc """
      Returns the list of defined states in this machine.
      """
      @spec states :: [atom]
      def states do
        @beepbop_states
      end

      @doc """
      Checks if given `state` is defined in this machine.
      """
      @spec state_defined?(atom) :: boolean
      def state_defined?(state) do
        Enum.member?(states(), state)
      end

      @doc """
      Validates the `context` and checks if the transition is valid.

      The `context` must contain a struct of type `#{@beepbop_schema_module}`
      under the `:#{@beepbop_schema_name}` key.
      """
      @spec validate_transition(%{}, [atom], atom, atom) :: :ok | {:error, String.t()}
      def validate_transition(context, from_states, to_state, event) do
        case _beepbop_extract_struct(context) do
          nil ->
            "#{@beepbop_schema_module} struct is missing from `context`"

          struct ->
            current_state =
              struct
              |> Map.fetch!(@beepbop_state_column)
              |> String.to_atom()

            if state_defined?(to_state) && Enum.member?(from_states, current_state) do
              :ok
            else
              "Cannot transition from '#{current_state}' to '#{to_state}' via '#{event}'"
            end
        end
      end

      defp _beepbop_expand_states(%{to: to, not: not_from}) when is_list(not_from) do
        {Enum.reject(states(), fn x -> x in not_from end), to}
      end

      defp _beepbop_expand_states(%{from: :any, to: to}) do
        {states(), to}
      end

      defp _beepbop_expand_states(%{from: from, to: to}) when is_list(from) do
        {from, to}
      end
    end
  end

  defmacro event(event, options, callback) do
    quote location: :keep do
      @doc """
      Runs the defined callback for this event.

      This function was generated by the `BeepBop.event/3` macro.
      """
      @spec unquote(event)(map, keyword) :: {:ok, map | struct} | {:error, term}
      def unquote(event)(context, opts \\ []) do
        persist? = Keyword.get(opts, :persist, true)
        repo_opts = Keyword.get(opts, :repo, [])
        {from_states, to_state} = _beepbop_expand_states(unquote(options))
        validity = validate_transition(context, from_states, to_state, unquote(event))

        if validity == :ok do
          {status, state_struct} =
            result =
            context
            |> case do
              %BeepBop.State{} = context -> context
              %{} = context -> BeepBop.State.new(context)
            end
            |> unquote(callback).()

          schema_struct = _beepbop_extract_struct(context)
          multi = _beepbop_try_persist(state_struct.multi, schema_struct, to_state)

          if status == :ok and persist? do
            repo = @beepbop_repo()
            repo.transaction(multi, @repo_opts)
          else
            {status, struct(state_struct, multi: multi)}
          end
        else
          {:error, validity}
        end
      end
    end
  end
end
