defmodule BeepBop do
  @moduledoc """
  Manages the state machine of an `Ecto.Schema`.
  """

  # TODO: These macros as really bad, make use of bind_quoted. Read up a real
  # book on macros.

  alias Ecto.Multi
  alias BeepBop.Utils

  @doc """
  Configures `BeepBop` to work with your `Ecto.Repo`.

  Expected keyword arguments:
  * `:ecto_repo` -- Since BeepBop does the routine persisting of "state", it
    needs to know which `Ecto.Repo` to use.
  """
  defmacro __using__(opts) do
    unless Keyword.has_key?(opts, :ecto_repo) do
      raise(~s{Please configure an Ecto.Repo by passing an Ecto.Repo
    like so:
    use BeepBop, ecto_repo: YourProject.Repo
})
    end

    quote location: :keep do
      import BeepBop
      alias Ecto.Multi

      def __beepbop__(:repo), do: Keyword.fetch!(unquote(opts), :ecto_repo)
    end
  end

  defmacro state_machine(schema, column, do: block) do
    # TODO: should validate that such a module exists and it does have the
    # specified column
    name = Utils.extract_schema_name(schema)

    quote location: :keep do
      @beepbop_name unquote(name)
      @beepbop_module unquote(schema)

      def __beepbop__(:name), do: @beepbop_name
      def __beepbop__(:module), do: @beepbop_module
      def __beepbop__(:column), do: unquote(column)

      defp _beepbop_try_persist(multi, struct, to_state) do
        Multi.run(multi, :persist, fn changes ->
          updated_struct = _beepbop_extract_struct(changes) || struct
          to = Atom.to_string(to_state)

          # TODO: Find an alternative to this construct,
          # When __MODULE__ has no persist/2, compiler throws a warning.
          #
          # A possible solution is to use Module.defines?/2 outside the quote
          # block... but how??
          try do
            __MODULE__.persist(updated_struct, to)
          rescue
            UndefinedFunctionError ->
              {:ok, Map.put(updated_struct, __beepbop__(:column), to)}
          end
        end)
      end

      defp _beepbop_extract_struct(context) do
        case Map.fetch(context, __beepbop__(:name)) do
          {:ok, %unquote(schema){} = struct} ->
            struct

          {:ok, _} ->
            nil

          :error ->
            nil
        end
      end

      # def valid_context?(%BeepBop.State{struct: %unquote(schema){}}), do: true
      def valid_context?(_), do: false

      unquote(block)
    end
  end

  defmacro states(states) do
    quote location: :keep do
      def __beepbop__(:states), do: unquote(states)

      @doc """
      Returns the list of defined states in this machine.
      """
      @spec states :: [atom]
      def states do
        __beepbop__(:states)
      end

      @doc """
      Checks if given `state` is defined in this machine.
      """
      @spec state_defined?(atom) :: boolean
      def state_defined?(state) do
        Enum.member?(states(), state)
      end

      defp _beepbop_expand_states(%{to: to, not: not_from}) when is_list(not_from) do
        {Enum.reject(states(), fn x -> x in not_from end), to}
      end

      defp _beepbop_expand_states(%{from: :any, to: to}) do
        {states(), to}
      end

      defp _beepbop_expand_states(%{from: from, to: to}) when is_list(from) do
        {from, to}
      end

      @doc """
      Validates the `context` struct and checks if the transition is valid.

      The `context` must contain a struct of type `#{@beepbop_module}`
      under the `:#{@beepbop_name}` key.
      """
      @spec validate_transition(%{}, [atom], atom, atom) :: :ok | {:error, String.t()}
      def validate_transition(context, from_states, to_state, event) do
        case _beepbop_extract_struct(context) do
          nil ->
            "#{@beepbop_module} struct is missing from `context`"

          struct ->
            current_state =
              struct
              |> Map.fetch!(__beepbop__(:column))
              |> String.to_atom()

            if state_defined?(to_state) && Enum.member?(from_states, current_state) do
              :ok
            else
              "Cannot transition from '#{current_state}' to '#{to_state}' via '#{event}'"
            end
        end
      end
    end
  end

  defmacro event(event, options, callback) do
    quote location: :keep do
      @doc """
      Runs the defined callback for this event.

      This function was generated by the `BeepBop.event/3` macro.
      """
      @spec unquote(event)(map, keyword) :: {:ok, map | struct} | {:error, term}
      def unquote(event)(context, opts \\ []) do
        persist? = Keyword.get(opts, :persist, true)
        repo_opts = Keyword.get(opts, :repo, [])
        {from_states, to_state} = Utils.expand_state(unquote(options))
        validity = validate_transition(context, from_states, to_state, unquote(event))

        if validity == :ok do
          {status, state_struct} =
            result =
            context
            |> case do
              %BeepBop.State{} = context -> context
              %{} = context -> BeepBop.State.new(context)
            end
            |> unquote(callback).()

          schema_struct = _beepbop_extract_struct(context)
          multi = _beepbop_try_persist(state_struct.multi, schema_struct, to_state)

          if status == :ok and persist? do
            repo = __beepbop__(:repo)
            repo.transaction(multi, repo_opts)
          else
            {status, struct(state_struct, multi: multi)}
          end
        else
          {:error, validity}
        end
      end
    end
  end
end
